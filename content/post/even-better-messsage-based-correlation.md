---
title: "Even better message based correlation"
date: 2009-03-02T00:00:00+02:00
draft: false
tags: [ ".NET", "WF", "WCF" ]
categories: [ ".NET" ]
---

As a follow up to my [previous](http://blogs.infosupport.com/blogs/jonathan/archive/2009/02/24/Message-based-correlation-with-WF_2F00_WCF-in-.NET-3.5.aspx) post, I've been extending my implementation a bit. In the comments section of my last post you might have read that we were thinking about creating a CorrelationSequenceActivity. I've implemented this activity now and it currently accepts only one child activity which should be a ReceiveActivity. This is validated using an activity validator. It has an attached property called CorrelationKey which will then appear on the ReceiveActivity. You can bind this property to whatever you want in you're workflow. Then when the CorrelationSequenceActivity is executed it registers the correlation key together with the instance ID of the workflow to a runtime service that implements IWorkflowCorrelationRuntimeService. When the CorrelationSequenceActivity is being closed it will automatically unregister the correlation key. We might have to extend this further in the future in order to support a scenario where the workflow is waiting for two events in parallel, each with their own correlation key, but that is not a scenario that we foresee right now.

Building the CorrelationSequenceActivity was quite easy, although I ran into a few problems with the attached property. It isn't as straight forward as using the [DependencyProperty.RegisterAttached](http://msdn.microsoft.com/en-us/library/system.workflow.componentmodel.dependencyproperty.registerattached.aspx) method. You'll have to implement the [IExtenderProvider](http://msdn.microsoft.com/en-us/library/system.componentmodel.iextenderprovider.aspx) interface and do all kinds of fancy stuff with designers. Luckily there's already some documentation on how this all works which you can find right [here](http://blogs.msdn.com/gblock/archive/2006/12/14/attached-properties-and-the-workflow-designer.aspx).

So how does this IWorkflowCorrelationRuntimeService interface work? Well, it has three operations, RegisterCorrelationKey, UnregisterCorrelationKey and LookupInstanceIdForCorrelationKey. The first two operations are called by the CorrelationSequenceActivity. The last one is called by the WorkflowCorrelationInstanceContextProvider I talked about in my previous post. So this should take care of correlating the correlation key that was extracted from the incoming message to the right workflow instance. It doesn't solve the extraction of the correlation key from the input message, but it should be theoretically possible to give the CorrelationSequenceActivity another attached property with a designer where you can select a property from the input message and which would then create an XPath query that extracts the key from the input message automagically. As we only have one service operation where we need to do correlation this isn't much of an issue for us right now.

Obviously the IWorkflowCorrelationRuntimeService interface allows for some extensibility. The WorkflowCorrelationEndpointBehavior from my previous post will try to get the configured one from the workflow runtime and if it doesn't find one it will insert a memory based one. This just works with an internal dictionary where the correlation keys and instance ID's are stored. I've also created a SqlWorkflowCorrelationRuntimeService that stores the correlation keys and their associated instance ID's into an extra table in the workflow persistence & tracking store. It implements [IPendingWork](http://msdn.microsoft.com/en-us/library/system.workflow.runtime.ipendingwork.aspx) so it participates in any transaction as needed. This doesn't work correctly when combined with the [SharedConnectionWorkflowCommitWorkBatchService](http://msdn.microsoft.com/en-us/library/system.workflow.runtime.hosting.sharedconnectionworkflowcommitworkbatchservice.aspx "http://msdn.microsoft.com/en-us/library/system.workflow.runtime.hosting.sharedconnectionworkflowcommitworkbatchservice.aspx"), but that's another story.

The only thing I haven't implemented yet is the [IEventActivity](http://msdn.microsoft.com/en-us/library/system.workflow.activities.ieventactivity.aspx) interface as my colleague Robert suggested. It shouldn't be too hard to implement this though, but we won't need it just yet.